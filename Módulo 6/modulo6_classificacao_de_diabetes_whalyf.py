# -*- coding: utf-8 -*-
"""Modulo6_Classificacao_de_diabetes_whalyf.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16LGXixBrmfdWdphK0BYtcmiXdsN2tY0u

# Projeto #6: Classificação de diabetes

- Base de dados
Smith, J.W., Everhart, J.E., Dickson, W.C., Knowler, W.C., & Johannes, R.S. (1988). Using the ADAP learning algorithm to forecast the onset of diabetes mellitus. In Proceedings of the Symposium on Computer Applications and Medical Care (pp. 261--265). IEEE Computer Society Press.

# Etapa 1: Importação das bibliotecas
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 2.x
import tensorflow as tf
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
tf.__version__

"""# Etapa 2: Importação da base de dados"""

diabetes = pd.read_csv('diabetes.csv')

diabetes

diabetes.head()

diabetes.tail()

diabetes.info()

diabetes.describe()

"""# Etapa 3: Limpeza e visualização dos dados"""

sns.countplot(x = 'Outcome', data = diabetes);

sns.pairplot(diabetes, hue = 'Outcome', 
             vars = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age']);

sns.heatmap(diabetes.corr(), annot = True);

X = diabetes.iloc[:, 0:8].values

X

y = diabetes.iloc[:, 8].values

y

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X = sc.fit_transform(X)

X

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2)

X_train.shape

X_test.shape

"""# Etapa 4: Construção e treinamento do modelo"""

# 8 -> 400 -> 400 -> 1
classifier = tf.keras.models.Sequential()
classifier.add(tf.keras.layers.Dense(units=400, activation='relu', input_shape=(8, )))
classifier.add(tf.keras.layers.Dropout(0.2))
classifier.add(tf.keras.layers.Dense(units=400, activation='relu'))
classifier.add(tf.keras.layers.Dropout(0.2))
classifier.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))

classifier.summary()

classifier.compile(optimizer='Adam', loss='binary_crossentropy', metrics = ['accuracy'])

epochs_hist = classifier.fit(X_train, y_train, epochs = 200)

y_pred = classifier.predict(X_test)

y_pred

y_pred = (y_pred > 0.5)

y_pred

"""# Etapa 6: Avaliação do modelo"""

epochs_hist.history.keys()

plt.plot(epochs_hist.history['loss'])
plt.title('Model Loss Progress During Training')
plt.xlabel('Epoch')
plt.ylabel('Training and Validation Loss')
plt.legend(['Training Loss']);

from sklearn.metrics import confusion_matrix
y_train_pred = classifier.predict(X_train)
y_train_pred = (y_train_pred > 0.5)
cm = confusion_matrix(y_train, y_train_pred)
sns.heatmap(cm, annot=True);

cm

from sklearn.metrics import classification_report
print(classification_report(y_train_pred, y_train))

cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True);

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred))